Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра Програмної інженерії



Звіт
З лабораторної роботи №1
з дисципліни «Скриптові мови програмування»









Виконав									Перевірив
ст.гр ПЗПІ-23-3 Світенко. С. М.					ст. в. Сокорчук І.П.







Харків 2025
1.1  Мета роботи
     
     
     ‒ ознайомитися з основними командами Bash для роботи з файлами та текстовими даними;
     ‒ навчитися використовувати команди select, ls, awk, sort, uniq, tee, cat, sed, iconv тощо;
     ‒ розробити Bash-скрипт для перетворення CSV файла розкладу занять у придатний для імпорту в Google Календар CSV формат.
     
     
1.2  Постановка задачі:
     
     
     Розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.
1.2.1 Ключі скрипта:
     ‒ --help — вивести довідку, завершити роботу та повернути успішний результат у батьківський процес;
     ‒ --version — вивести інформацію про версію, завершити роботу та повернути успішний результат у батьківський процес;
     ‒ -q або --quiet — не виводити інформацію в стандартний потік виведення.
1.2.2 Параметри: 
     ‒ академ_група — назва академічної групи (шаблон);
     ‒ файл_із_cist.csv — експортований CSV файл розкладу занять.
1.2.3 Обробка файла 
     ‒ читати вхідний CSV файл та вибирати рядки, що відповідають вибраній академічній групі;
     ‒ визначити порядкий номер для кожного заняття (лекція, практичне заняття, лабораторна робота) із врахуванням того, що лабораторні роботи складаються із двох пар, а решта занять — із однієї пари;
     ‒ створити поле «Subject» із поля «Тема» вхідного CSV файла, але БЕЗ назви академічної групи та дефіса на початку цього поля ("ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1");
     ‒ додати порядковий номер наприкінці теми (Subject) кожного заняття після крапки з комою (опис заняття; №1);
     ‒ переформатувати дату та час до формату «mm/dd/yyyy, HH:MM AM|PM,» Gogle Календаря 12-годинний формат часу. Наприклад: 02/30/2025, 11:15 AM;
     ‒ заповнити поле «Description» текстом із поля «Опис (Описание)» вхідного CSV файла;
     ‒ відформатувати дані відповідно до вимог Google Календаря https://support.google.com/calendar/;
     ‒ виводити створені для Google Календаря дані у стандартний потік виведення, якщо це не заблоковано ключем -q або –quiet;
     ‒ записати результат у новий файл із назвою: Google_TimeTable_??_??_20??.csv, де ??_??_20?? — дата, що відповідає вхідному файлу.
1.2.4 Обробка помилок
     ‒ якщо файл не знайдено або файл є недоступним для читання, вивести повідомлення про помилку в стандартний потік помилок та повернути код помилки;
     ‒ якщо група не знайдена у вибраному файлі, повідомити про це користувача та запропонувати вибір іншої групи;
     ‒ якщо група не вказана, але у вказаному файлі присутня лише одна група, створити CSV файл Google Календаря для цієї групи;
     ‒ якщо сталася помилка під час обробки файла, повідомити про це та завершити роботу з відповідним кодом помилки.
1.2.5 Обробка відсутніх аргументів
     Якщо при виклику скрипта не вказана академічна група або вхідний CSV файл, то скрипт повинен:
     ‒ вивести меню вибору файла за допомогою команди select та сформувати відсортований за датою в іменах файлів (від старіших до новіших) список доступних у поточній директорії CSV файлів за шаблоном:  TimeTable_??_??_20??.csv;
     ‒ відкрити вибраний CSV файл та згенерувати список академічних груп, що містяться у файлі, відсортувати їх за алфавітом (sort, uniq) та вивести меню вибору групи за допомогою select.
1.2.6 Додаткові вимоги:
     а) Скрипт має необхідні права доступу:
1. файл скрипта виконуваний для всіх користувачів;
2. редагування файла скрипта дозволене лише власнику файла.
     
     
1.3  Написання алгоритму
1.3.1 Конвертація кодування
     Конвеєрна обробка CSV-файлу реалізована шляхом послідовного застосування трьох основних команд, що забезпечують підготовку даних до подальшої обробки. На першому етапі, за допомогою утиліти «iconv» (рядок 004), вхідний файл конвертується з кодування CP1251 у UTF-8, що гарантує коректне відображення кириличних символів у подальших операціях. Далі використовується команда «tr», яка замінює всі символи повернення каретки («\r») на символи нового рядка («\n»), уніфікуючи структуру рядків незалежно від операційної системи, у якій був створений початковий файл.
     Після цього підготовлені дані передаються у потік обробки «awk», де визначається роздільник полів (",") для коректного розбору CSV-структури. На цьому етапі відбувається фільтрація рядків за заданою академічною групою, а також початкове форматування дат і часу. Такий підхід дозволяє ефективно підготувати дані до подальших трансформацій, забезпечуючи їхню чистоту та структурованість для наступних кроків скрипта.
       4:     iconv -f cp1251 -t UTF-8 "$data_file"| tr '\r' '\n' | awk -F'","' -v group_arg="$group" '
1.3.2 Форматування часу
     Форматування часу у скрипті реалізовано за допомогою спеціальної функції format_time_to_ampm, яка оголошена у блоці обробки awk на рядках 005–017. Дана функція приймає вхідний час у 24-годинному форматі (наприклад, «14:30») і перетворює його у 12-годинний формат із зазначенням AM або PM, що відповідає вимогам багатьох західних календарних сервісів, зокрема Google Calendar.
     Алгоритм функції передбачає розділення вхідного рядка часу на години та хвилини, визначення періоду доби (AM чи PM) залежно від значення годин, а також коригування числового значення години відповідно до 12-годинного формату (наприклад, 00:15 → 12:15 AM, 13:45 → 01:45 PM). Форматований результат повертається у вигляді рядка з провідним нулем для годин, якщо це необхідно, та з відповідною позначкою AM або PM. Виклик цієї функції здійснюється у процесі обробки кожного рядка CSV (рядки 031 та 032), де час початку та завершення заняття передається на форматування перед формуванням фінального структурованого запису.
       05:     function format_time_to_ampm(time_string, temp_array, hrs, mins, period, formatted_output) {
       06:         split(time_string, temp_array, ":");
       07:         hrs = temp_array[1] + 0;
       08:         mins = temp_array[2];
       09:         
       10:         period = (hrs >= 12) ? "PM" : "AM";
       11:         hrs = (hrs % 12);
       12:         if (hrs == 0) hrs = 12;
       13:         
       14:         formatted_output = (hrs < 10 ? "0" hrs : hrs) ":" mins " " period;
       15:         
       16:         return formatted_output;
       17:     }	
     Форматування часу для кожного рядка здійснюється на рядках 031 та 032:
       31:             transformed_start_time = format_time_to_ampm($3)
       32:             transformed_end_time = format_time_to_ampm($5)
     Таким чином, логіка форматування часу повністю зосереджена у функції «format_time_to_ampm» (рядки 005–017), а її використання – у процесі обробки кожного рядка CSV (рядки 031–032).
1.3.3 Обробка рядків
     Обробка рядків у скрипті здійснюється у рамках awk-блоку, який починається після попередньої підготовки даних (рядки 019–035). На цьому етапі для кожного рядка CSV-файлу виконується розбір полів, фільтрація за академічною групою та формування структурованих даних для подальшого використання.
     На початку блоку (рядок 020) відбувається розбиття першого поля на масив «class_info» для виділення інформації про групу. Далі, у рядку 021, здійснюється перевірка на відповідність поточного рядка заданій групі: якщо назва групи збігається з аргументом «group_arg», а також довжина назви відповідає очікуваній, рядок обробляється далі. У рядках 022–023 видаляється зайва інформація з назви курсу, після чого у рядках 025–029 дати початку та завершення заняття перетворюються у формат MM/DD/YYYY для сумісності з Google Calendar. Час початку та завершення заняття передається на форматування у функцію «format_time_to_ampm» (рядки 031–032). Нарешті, у рядку 034 формується проміжковий рядок із полями, розділеними символом «+», який передається на подальше сортування та обробку. Такий підхід забезпечує точне виділення, фільтрацію та первинне структурування даних для наступних етапів скрипта.
       19:     {
       20:         split($1, class_info, " ")
       21:         if (class_info[1] ~ group_arg && (length(class_info[1]) - 1) == length(group_arg)) {
       22:             course = substr($1, 2)
       23:             sub("^" group_arg " - ", "", course)
       24: 
       25:             split($2, date_parts, ".");
       26:             transformed_start_date = date_parts[2] "/" date_parts[1] "/" date_parts[3];
       27: 
       28:             split($4, date_parts, ".");
       29:             transformed_end_date = date_parts[2] "/" date_parts[1] "/" date_parts[3];
       30: 
       31:             transformed_start_time = format_time_to_ampm($3)
       32:             transformed_end_time = format_time_to_ampm($5)
       33:             
       34:             print course "+" transformed_start_date "+" transformed_start_time "+" transformed_end_date "+" transformed_end_time "+" $12
       35:         }
       36:     }' | sort -t"+" -k1,1 -k2,2 | awk -F'+' -v last_subj="$last_subj" -v item_num="$item_num" -v lab_seq="$lab_seq" '
1.3.4 Сортування та фіналізація
     Після первинної обробки та структурування даних скрипт переходить до етапу сортування і фіналізації результатів. На цьому кроці всі записи впорядковуються за назвою предмета та датою проведення, що дозволяє згрупувати заняття одного предмета разом і розташувати їх у хронологічному порядку. Такий підхід забезпечує логічну послідовність даних у фінальному файлі, роблячи його зручним для подальшого імпорту або аналізу.
     Після сортування формується фінальний вигляд таблиці: додається заголовок, а кожному заняттю присвоюється порядковий номер відповідно до його типу (наприклад, для лабораторних робіт реалізовано особливу логіку нумерації). Усі записи перетворюються у формат, сумісний із Google Calendar, що дозволяє безпосередньо імпортувати отриманий файл у календарні сервіси. Така фіналізація гарантує структурованість, зрозумілість і практичну цінність вихідних даних.
       37:     {
       38:         if(NR == 1){
       39:             print("Subject,Start Date,Start Time,End Date,End Time,Description");
       40:         }
       41:         if($1 == last_subj){
       42:             if($1 ~ "Лб"){
       43:                 if(lab_seq % 2 == 1){
       44:                     print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       45:                 } else {
       46:                     item_num += 1
       47:                     print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       48:                 }
       49:                 lab_seq += 1
       50:             } else {
       51:                 item_num += 1
       52:                 print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       53:             }
       54:         } else {
       55:             lab_seq = 1
       56:             item_num = 1
       57:             print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       58:         }
       59:         last_subj = $1
       60:     }'
1.3.5 Проміжне виведення та виведення довідки
     Механізм виведення версії скрипта реалізовано через окрему функцію, яка при виклику просто повідомляє поточну версію програми. Це дозволяє користувачу швидко дізнатися, яку саме версію скрипта він використовує, що особливо корисно для супроводу й оновлення програмного забезпечення.
       63: print_version() {
       64:     echo "task2 version 1.0.0"
       65: }
     Механізм виведення довідки (help) у скрипті реалізовано через окрему функцію, яка виводить коротку інструкцію з використання та опис доступних параметрів. Це забезпечує користувача необхідною інформацією для правильного запуску та налаштування скрипта без потреби звертатися до зовнішньої документації.
       67: show_manual() {
       68:     echo "Використання: {login_name}-task2 [--help | --version] | [[-q|--quiet] [group] [timetable_file.csv]"
       69:     echo
       70:     echo "Параметри:"
       71:     echo "  --help           Показати опис"
       72:     echo "  --version        Показати версію скрипта"
       73:     echo "  -q, --quiet      Не виводити інформацію на екран"
       74:     echo "  timetable_file.csv    Шлях до CSV файлу (Необов'язково)"
       75:     echo "  group            Академічна група (Необов'язково)"
       76: }
     
1.3.6 Вибір файлу, групи 
     Вибір файлу для обробки у скрипті реалізовано через окрему функцію, яка автоматично знаходить усі файли розкладу за заданим шаблоном і пропонує користувачу обрати потрібний варіант зі списку. Для цього використовується цикл select, який створює інтерактивне меню вибору: користувач бачить перелік доступних файлів і вводить номер відповідного варіанта. Після вибору скрипт перевіряє існування та доступність обраного файлу для читання, що гарантує коректну подальшу роботу.
       078: select_timetable_file() {
       079:     if [[ -z "$data_file" ]]; then
       080:         pattern="TimeTable_??_??_20??.csv"
       081: 
       082:         available_files=($(ls -1t $pattern))
       083: 
       084:         if [[ ${#available_files[@]} -eq 0 ]]; then
       085:             echo "Не знайдено файлів за шаблоном: $pattern"
       086:             exit 1
       087:         fi
       088: 
       089:         echo "Оберіть файл:"
       090:         select selected_file in "${available_files[@]}"; do
       091:             if [[ -n "$selected_file" ]]; then
       092:                 echo "Ви обрали: $selected_file"
       093:                 data_file=$selected_file
       094:                 break
       095:             else
       096:                 echo "Неправильний вибір, спробуйте ще раз"
       097:             fi
       098:         done
       099:     fi
       100: 
       101:     if [ ! -e "$data_file" ]; then
       102:         echo "Файл не існує"
       103:         exit 1
       104:     fi
       105: 
       106:     if [ ! -r "$data_file" ]; then
       107:         echo "Файл недоступний для читання"
       108:         exit 1
       109:     fi
       110: }
     Схожий механізм реалізує функція «determine_student_group()», що відповідає за вибір академічної групи.
1.3.7 Обробка параметрів
     Обробка параметрів командного рядка у скрипті організована так, щоб забезпечити гнучкість і зручність для користувача. Скрипт автоматично розпізнає спеціальні ключі — такі як виклик довідки, виведення версії або активація тихого режиму — і виконує відповідні дії без подальшої обробки. Якщо ж користувач передає додаткові аргументи, вони трактуються як значення для вибору академічної групи та/або файлу розкладу, залежно від їх кількості та порядку.
     Такий підхід стає можливим завдяки використанню умовних конструкцій Bash для перевірки значень позиційних параметрів ($1, $2 тощо) та операторів порівняння. На початку виконання скрипта реалізовано послідовну перевірку: якщо перший аргумент відповідає одному зі спеціальних ключів, викликається відповідна функція (наприклад, show_manual або print_version), а у випадку тихого режиму додатково використовується команда shift для коректної обробки наступних параметрів. Далі, залежно від кількості залишкових аргументів, вони автоматично присвоюються відповідним змінним (група, файл).
     Перевірка спеціальних ключів (--help, --version, -q, --quiet) і відповідна реакція (виклик функцій, встановлення режиму silent, зсув параметрів): 
       143: if [[ "$1" == "--help" ]]; then
       144:     show_manual
       145:     exit 0
       146: elif [[ "$1" == "--version" ]]; then
       147:     print_version
       148:     exit 0
       149: elif [[ "$1" == "-q" || "$1" == "--quiet" ]]; then
       150:     silent=true
       151:     shift
       152: fi
     Присвоєння значень змінним «data_file» та «group» залежно від кількості переданих параметрів:
       154: if [[ $# -eq 1 ]]; then
       155:     data_file="$1"
       156:     group=""
       157: elif [[ $# -eq 2 ]]; then
       158:     group="$1"
       159:     data_file="$2"
       160: else
       161:     group=""
       162:     data_file=""
       163: fi
1.3.8 Основний цикл скрипта
     Основний цикл роботи скрипта побудований як послідовність викликів функцій і умовних операторів, які організовують виконання всіх ключових етапів обробки даних. Після завершення розбору параметрів командного рядка, скрипт послідовно викликає функції для вибору файлу розкладу та академічної групи, забезпечуючи інтерактивність і коректність вхідних даних. Далі основна логіка полягає у запуску функції обробки CSV-файлу, результат якої зберігається у новий файл; при цьому підтримується як звичайний, так і тихий режим роботи.
     Після завершення обробки перевіряється код завершення виконання основної функції: у разі помилки користувачу виводиться відповідне повідомлення, а у випадку успіху — підтвердження про створення результатного файлу.
       165: select_timetable_file
       166: determine_student_group
       167: 
       168: result_file="Google_${data_file}"
       169: 
       170: if [[ "$silent" == true ]]; then
       171:     convert_csv_data >"$result_file"
       172:     exit_code=$?
       173: else
       174:     convert_csv_data | tee "$result_file"
       175:     exit_code=${PIPESTATUS[0]}
       176: fi
       177: 
       178: if [[ $exit_code -ne 0 ]]; then
       179:     echo "Помилка під час обробки файлу"
       180:     exit 2
       181: fi
       182: 
       183: echo "Файл успішно оброблено та збережено як $result_file"
       184: exit 0
1.4  Тестування програми
     З усіма аргументами на місці та коректним файлом:
       svite@SOFIA-ACER MINGW64 /f/Github/smp-pzpi-23-3-svitenko-sofiia/Lab1/smp-pzpi-23-3-svitenko-sofiia-lab1-code (main)
       $ ./lb1.bash ПЗПІ-23-3 TimeTable_06_06_2025.csv
       Subject,Start Date,Start Time,End Date,End Time,Description
       *ВІА Зал DL *ВІА(ПЗПІ-23-)-3; №1,06/12/2025,07:45 AM,06/12/2025,09:20 AM,*ВІА Зал DL *ВІА(ПЗПІ-23-)-3
       *ВІА Лб DL *ВІА(ПЗПІ-23-)-3; №1,03/12/2025,07:45 AM,03/12/2025,09:20 AM,*ВІА Лб DL *ВІА(ПЗПІ-23-)-3
       *ВІА Лб DL *ВІА(ПЗПІ-23-)-3; №1,03/12/2025,09:30 AM,03/12/2025,11:05 AM,*ВІА Лб DL *ВІА(ПЗПІ-23-)-3
       *ВІА Лб DL *ВІА(ПЗПІ-23-)-3; №2,04/02/2025,07:45 AM,04/02/2025,09:20 AM,*ВІА Лб DL *ВІА(ПЗПІ-23-)-3
       *ВІА Лб DL *ВІА(ПЗПІ-23-)-3; №2,04/02/2025,09:30 AM,04/02/2025,11:05 AM,*ВІА Лб DL *ВІА(ПЗПІ-23-)-3
З усіма аргументами, але відсутньою групою у файлі:
       svite@SOFIA-ACER MINGW64 /f/Github/smp-pzpi-23-3-svitenko-sofiia/Lab1/smp-pzpi-23-3-svitenko-sofiia-lab1-code (main)
       $ ./lb1.bash --quiet ПЗПІ-23-3 TimeTable_06_06_2025.csv
       Файл успішно оброблено та збережено як Google_TimeTable_06_06_2025.csv
     Нічого не було надруковано в стандартний потік, але файл був сформований коректно.
1.5  Висновок
     У ході виконання лабораторної роботи було опановано основні інструменти Bash для обробки текстових даних і роботи з файлами. В рамках завдання розроблено Bash-скрипт, призначений для автоматизованого перетворення розкладу занять у формат, придатний для імпорту до Google Календаря. У процесі виконання роботи набуті практичні навички використання утиліт awk, sed, sort, uniq, select, iconv та інших, а також реалізації обробки параметрів командного рядка, перевірки помилок і форматування даних відповідно до заданих вимог.
     Розроблений скрипт успішно виконує обробку CSV-файлів, забезпечує інтерактивний вибір академічної групи та формує коректний календарний файл для подальшого використання. Отримані знання та досвід можуть бути ефективно застосовані для автоматизації рутинних процесів обробки табличних даних у навчальній та професійній діяльності.


     ДОДАТОК А
     Повний код програми
     Посилання на повіний код програми у GitHub:https://github.com/NureSvitenkoSofiia/smp-pzpi-23-3-svitenko-sofiia/tree/main/Lab1/smp-pzpi-23-3-svitenko-sofiia-lab1-code
       001: #!/bin/bash
       002: 
       003: convert_csv_data() {
       004:     iconv -f cp1251 -t UTF-8 "$data_file"| tr '\r' '\n' | awk -F'","' -v group_arg="$group" '
       005:     function format_time_to_ampm(time_string, temp_array, hrs, mins, period, formatted_output) {
       006:         split(time_string, temp_array, ":");
       007:         hrs = temp_array[1] + 0;
       008:         mins = temp_array[2];
       009:         
       010:         period = (hrs >= 12) ? "PM" : "AM";
       011:         hrs = (hrs % 12);
       012:         if (hrs == 0) hrs = 12;
       013:         
       014:         formatted_output = (hrs < 10 ? "0" hrs : hrs) ":" mins " " period;
       015:         
       016:         return formatted_output;
       017:     }
       018: 
       019:     {
       020:         split($1, class_info, " ")
       021:         if (class_info[1] ~ group_arg && (length(class_info[1]) - 1) == length(group_arg)) {
       022:             course = substr($1, 2)
       023:             sub("^" group_arg " - ", "", course)
       024: 
       025:             split($2, date_parts, ".");
       026:             transformed_start_date = date_parts[2] "/" date_parts[1] "/" date_parts[3];
       027: 
       028:             split($4, date_parts, ".");
       029:             transformed_end_date = date_parts[2] "/" date_parts[1] "/" date_parts[3];
       030: 
       031:             transformed_start_time = format_time_to_ampm($3)
       032:             transformed_end_time = format_time_to_ampm($5)
       033:             
       034:             print course "+" transformed_start_date "+" transformed_start_time "+" transformed_end_date "+" transformed_end_time "+" $12
       035:         }
       036:     }' | sort -t"+" -k1,1 -k2,2 | awk -F'+' -v last_subj="$last_subj" -v item_num="$item_num" -v lab_seq="$lab_seq" '
       037:     {
       038:         if(NR == 1){
       039:             print("Subject,Start Date,Start Time,End Date,End Time,Description");
       040:         }
       041:         if($1 == last_subj){
       042:             if($1 ~ "Лб"){
       043:                 if(lab_seq % 2 == 1){
       044:                     print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       045:                 } else {
       046:                     item_num += 1
       047:                     print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       048:                 }
       049:                 lab_seq += 1
       050:             } else {
       051:                 item_num += 1
       052:                 print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       053:             }
       054:         } else {
       055:             lab_seq = 1
       056:             item_num = 1
       057:             print($1 "; №" item_num "," $2 "," $3 "," $4 "," $5 "," $6)
       058:         }
       059:         last_subj = $1
       060:     }'
       061: }
       062: 
       063: print_version() {
       064:     echo "task2 version 1.0.0"
       065: }
       066: 
       067: show_manual() {
       068:     echo "Використання: {login_name}-task2 [--help | --version] | [[-q|--quiet] [group] [timetable_file.csv]"
       069:     echo
       070:     echo "Параметри:"
       071:     echo "  --help           Показати опис"
       072:     echo "  --version        Показати версію скрипта"
       073:     echo "  -q, --quiet      Не виводити інформацію на екран"
       074:     echo "  timetable_file.csv    Шлях до CSV файлу (Необов'язково)"
       075:     echo "  group            Академічна група (Необов'язково)"
       076: }
       077: 
       078: select_timetable_file() {
       079:     if [[ -z "$data_file" ]]; then
       080:         pattern="TimeTable_??_??_20??.csv"
       081: 
       082:         available_files=($(ls -1t $pattern))
       083: 
       084:         if [[ ${#available_files[@]} -eq 0 ]]; then
       085:             echo "Не знайдено файлів за шаблоном: $pattern"
       086:             exit 1
       087:         fi
       088: 
       089:         echo "Оберіть файл:"
       090:         select selected_file in "${available_files[@]}"; do
       091:             if [[ -n "$selected_file" ]]; then
       092:                 echo "Ви обрали: $selected_file"
       093:                 data_file=$selected_file
       094:                 break
       095:             else
       096:                 echo "Неправильний вибір, спробуйте ще раз"
       097:             fi
       098:         done
       099:     fi
       100: 
       101:     if [ ! -e "$data_file" ]; then
       102:         echo "Файл не існує"
       103:         exit 1
       104:     fi
       105: 
       106:     if [ ! -r "$data_file" ]; then
       107:         echo "Файл недоступний для читання"
       108:         exit 1
       109:     fi
       110: }
       111: 
       112: determine_student_group() {
       113:     available_units=($(iconv -f cp1251 -t UTF-8 "$data_file"| tr '\r' '\n' | awk -F',' 'NR > 1 {print substr($1,2,10)}' | sort | uniq))
       114: 
       115:     if [[ -z "$group" && ${#available_units[@]} -eq 1 ]]; then
       116:         group=${available_units[0]}
       117:         echo "Знайдено лише одну групу: $group. Використовуємо цю групу."
       118:     elif [[ -z "$group" ]]; then
       119:         echo "Оберіть групу:"
       120:         select option in ${available_units[@]}; do
       121:             if [[ -n "$option" ]]; then
       122:                 group=$option
       123:                 break
       124:             else
       125:                 echo "Неправильний вибір, спробуйте ще раз"
       126:             fi
       127:         done
       128:     elif [[ ! " ${available_units[*]} " =~ " ${group} " ]]; then
       129:         echo "Вказана група не знайдена у файлі, оберіть іншу: "
       130:         select option in ${available_units[@]}; do
       131:             if [[ -n "$option" ]]; then
       132:                 group=$option
       133:                 break
       134:             else
       135:                 echo "Неправильний вибір, спробуйте ще раз"
       136:             fi
       137:         done
       138:     fi
       139: }
       140: 
       141: silent=false
       142: 
       143: if [[ "$1" == "--help" ]]; then
       144:     show_manual
       145:     exit 0
       146: elif [[ "$1" == "--version" ]]; then
       147:     print_version
       148:     exit 0
       149: elif [[ "$1" == "-q" || "$1" == "--quiet" ]]; then
       150:     silent=true
       151:     shift
       152: fi
       153: 
       154: if [[ $# -eq 1 ]]; then
       155:     data_file="$1"
       156:     group=""
       157: elif [[ $# -eq 2 ]]; then
       158:     group="$1"
       159:     data_file="$2"
       160: else
       161:     group=""
       162:     data_file=""
       163: fi
       164: 
       165: select_timetable_file
       166: determine_student_group
       167: 
       168: result_file="Google_${data_file}"
       169: 
       170: if [[ "$silent" == true ]]; then
       171:     convert_csv_data >"$result_file"
       172:     exit_code=$?
       173: else
       174:     convert_csv_data | tee "$result_file"
       175:     exit_code=${PIPESTATUS[0]}
       176: fi
       177: 
       178: if [[ $exit_code -ne 0 ]]; then
       179:     echo "Помилка під час обробки файлу"
       180:     exit 2
       181: fi
       182: 
       183: echo "Файл успішно оброблено та збережено як $result_file"
       184: exit 0


     ДОДАТОК Б
     Відеозапис
     Посилання на відеозахист: https://youtu.be/yYVFXz0NtHk
00:00 — Вступ, мета: освоїти bash-команди для роботи з файлами, селекторами
00:31 — Постановка задачі: обробити CSV-розклад, перетворити для імпорту в Google Календар
03:22 — Відкриття файлу, генерація списку груп, меню вибору групи
03:38 — Додаткові вимоги: права доступу, скрипт лише для виконання
03:53 — Звіт: алгоритм, конвертація кодування, форматування часу, обробка рядків, тестування
04:27 — Додаток: повний код (A), пояснення до відео (B)
04:39 — Демонстрація запуску з різними параметрами (help, version, quiet), показ роботи
05:32 — Пояснення коду: shebang, функція конвертації
06:01 — Перекодування файлу, підготовка рядків
06:29 — Обробка через awk: розбір полів, форматування часу
07:18 — Для кожного рядка — розбір групи, формування полів, перетворення дат і часу
09:02 — Формування фінального рядка для Google Календаря
09:33 — Сортування та нумерація занять
10:20 — Врахування лабораторних, підрахунок номерів, оновлення subject
11:12 — Функції для виводу версії, інструкції
12:13 — Вибір файлу розкладу, формування списку файлів
12:47 — Якщо файлів немає — повідомлення, завершення
13:14 — Вибір групи, перевірка існування файлу
13:31 — Якщо файл не існує — помилка
13:50 — Визначення унікальних груп, автоматичний вибір, якщо група одна
14:09 — Якщо група не задана — меню вибору
14:23 — Якщо група не знайдена — повідомлення, повторний вибір
14:35 — Встановлення режиму виводу (тихий/звичайний)
14:48 — Обробка аргументів командного рядка (help, version, quiet)
15:20 — Визначення змінних для групи і файлу
15:46 — Виклик функцій вибору файлу та групи
16:01 — Формування імені результуючого файлу
16:16 — Тихий режим — тільки запис у файл, інакше ще й вивід на екран
16:46 — Перевірка коду завершення, повідомлення про помилку
17:14 — Повідомлення про успішну обробку, завершення скрипта
17:30 — Завершення, подяка
       
     
     14
     
     
     
     
     
